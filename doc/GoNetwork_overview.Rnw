\documentclass{article}
\title{Using GoNetwork}
\author{Sara Linker}

\usepackage{Sweave}
\begin{document}
\maketitle
\SweaveOpts{concordance=TRUE}

\section*{Introduction}
  The purpose of GoNetwork is to create a functionally enriched gene network using GO terminology. Networks created using this program are easily plotted with molecular visualization software platforms such as Cytoscape.  The sample data used in this markdown is a list of homo sapien genes downloaded from the AmiGO 2 website associated with the following go terms: intracellular transport (GO:0046907), intracellular vesicle (GO:0097708), ATP binding (GO:0005524), postsynaptic density (GO:0014069), and negative regulation of transcription from polymerase II promoter (GO:0000122). \textit{Is it overkill to type out all of the GO terms and numbers?}

<<Internal Functions, echo=FALSE>>=
#############################################
## GoNetwork_slinker, created 11/20/2015
## Purpose: Generate a network of how genes are linked based on GO terminology
## Requirements: reshape, biomaRt, lsa, GO.db
## User Input: genes, that's it!
## Other functions that can be added if you ask (just no time right now)
##    - adding in important variables so you can color/size/etc... based on FC or p-value in cytoscape
#############################################
# LOAD Public functions --------------------------------------------------------
library(reshape)
library(biomaRt)
library(lsa)
library(GO.db)
library(modes)
##
#load("~/Documents/BrainRProject/test.rda")

# LOAD Homemade functions -------------------------------------------------
getGo <- function(genes, species = "mouse", preMinCol = 0, preMinRow = 0){
  if(species == "human"){
    ensembl <- useMart("ensembl",dataset="hsapiens_gene_ensembl")
  }else if (species == "mouse"){
    ensembl <- useMart("ensembl",dataset="mmusculus_gene_ensembl")
  }else{
    warning("species not interpretable, try using human or mouse")
  }
  filter <- c("external_gene_name") #TRY: listFilters(ensembl)
  attrib <- c("external_gene_name","name_1006","go_id","namespace_1003")
  res = getBM(attributes=attrib,filters=filter,values=genes,mart=ensembl)
  
  ##########################
  ######## Create a {0,1} table of term belongingness per gene
  ##########################
  tab <- table(res$name_1006)
  tab <- tab[-(c(which(names(tab) == "")))]
  M <- as.data.frame(matrix(data = 0,nrow=length(genes),ncol=length(tab)))
  rownames(M) <- genes
  colnames(M) <- names(tab)
  res <- res[res$name_1006 != "",]
  for (g in genes){
    group <- res[res$external_gene_name == g,"name_1006"]
    #group <- group[-c(which(group == ""))]
    M[g,group] <- 1
  }
  ##########################
  ######## Create a table of term parents and children
  ##########################
  terms <- data.frame(id = res$go_id , space = res$namespace_1003, name = res$name_1006)
  terms <- unique(terms[terms$id != "",])
  #BP
  bp <- terms[terms$space == "biological_process",]
  bp2 <- as.vector(lapply(as.character(bp$id),function(x) (length(GOBPANCESTOR[[x]]) )))
  bp$parents <- bp2
  #CC
  cc <- terms[terms$space == "cellular_component",]
  cc2 <- as.vector(lapply(as.character(cc$id),function(x) (length(GOCCANCESTOR[[x]]) )))
  cc$parents <- cc2
  #MF
  mf <- terms[terms$space == "molecular_function",]
  mf2 <- as.vector(lapply(as.character(mf$id),function(x) (length(GOMFANCESTOR[[x]]) )))
  mf$parents <- mf2
  
  terms <- as.data.frame(rbind(bp,cc,mf))
  #######################
  ## Multiply each column by its respective number of parents
  #######################
  M2 <- M
  for (i in 1:ncol(M)){
    M2[,colnames(M)[i]] <- M[,colnames(M)[i]] * unlist(terms[terms$name == colnames(M)[i],"parents"])
  }
  M2[is.na(M2)] <- 0 
  Col <- colSums(M2)
  Row <- rowSums(M2)
  M2 <- M2[as.vector(Row) > preMinRow ,as.vector(Col) > preMinCol]
  
  return(M2)
}
getGo_bin <- function(genes, species = "mouse", preMinCol = 0, preMinRow = 0){
  if(species == "human"){
    ensembl <- useMart("ensembl",dataset="hsapiens_gene_ensembl")
  }else if (species == "mouse"){
    ensembl <- useMart("ensembl",dataset="mmusculus_gene_ensembl")
  }else{
    warning("species not interpretable, try using human or mouse")
  }
  filter <- c("external_gene_name") #TRY: listFilters(ensembl)
  attrib <- c("external_gene_name","name_1006","go_id","namespace_1003")
  res = getBM(attributes=attrib,filters=filter,values=genes,mart=ensembl)
  
  ##########################
  ######## Create a {0,1} table of term belongingness per gene
  ##########################
  tab <- table(res$name_1006)
  if (sum(names(tab) == "") > 0){
    tab <- tab[-(c(which(names(tab) == "")))]
  }
  M <- as.data.frame(matrix(data = 0,nrow=length(genes),ncol=length(tab)))
  rownames(M) <- genes
  colnames(M) <- names(tab)
  res <- res[res$name_1006 != "",]
  for (g in genes){
    group <- res[res$external_gene_name == g,"name_1006"]
    #group <- group[-c(which(group == ""))]
    M[g,group] <- 1
  }
  Col <- colSums(M)
  Row <- rowSums(M)
  M <- M[as.vector(Row) > preMinRow ,as.vector(Col) > preMinCol]
  return(M)
}
OuterFun <- function(i){
  x <- as.numeric(M2[i,])
  tmp <- lapply(1:nrow(M2), InnerFun,x=x)
}
InnerFun <- function(j,x){
  y <- as.numeric(M2[j,])
  return(cosine(x,y))
}

exactTerms <- function(x,term = "nuclear"){
  tmp <- x[grep(term,x,ignore.case=TRUE)]
  return(tmp)
}
findGenes <- function(M,term = "nuclear"){
  tmp <- M[,grep(term,colnames(M),ignore.case=TRUE)]
  if(!is.null(dim(tmp))){
    tmp2 <- tmp[rowSums(tmp) > 0,]
  }else{
    tmp2 <- tmp[rowSums(tmp) > 0,]
    tmp2 <- as.list(tmp2)
    names(tmp2) <- rownames(M[tmp> 0,])
  }
  return(rownames(tmp2))
  
}
findTerms <- function(M,geneA,geneB=NA,geneC=NA,geneD=NA){
  genecount <- 1
  a <- M[geneA,] 
  a <- names(a[which(a > 0)])
  if(!is.na(geneB)){
    genecount  = genecount + 1
    b <- M[geneB,] 
    a <- c(a,names(b[which(b > 0)]))
  }
  if(!is.na(geneC)){
    genecount  = genecount + 1
    b <- M[geneC,] 
    a <- c(a,names(b[which(b > 0)]))
  }
  if(!is.na(geneD)){
    genecount  = genecount + 1
    b <- M[geneD,] 
    a <- c(a,names(b[which(b > 0)]))
  }
  a <- table(a)
  return(names(a[a==genecount]))
}

@

<<GoTheDist Function, echo=FALSE>>=
GoTheDist <-function(M,method,Min = 4,minparents =   8, MinRow = 0,Threads = NULL){
  require(parallel)
  M2 <- M[,(as.vector(apply(M,2,function(x) sum(x > 0))) > Min)]
  parent <- as.numeric(apply(X=M2,MARGIN=2,max))
  M2 <- M2[,parent >= minparents]
  M2 <- M2[rowSums(M2) > MinRow,]
  if (!is.null(Threads)){#if using a big matrix we can parallelize it across multiple threads using this function. However, in order to do that we need to use a function that takes advantage of the ability to run in parallel. Cosine doesn't automatically do this so we use the InnerFun and OuterFun to run our own loops through the matrix
    cl <- makeCluster(getOption("cl.cores",  Threads))
    clusterExport(cl=cl, varlist=c("M2","InnerFun","cosine"))
    tmp <- parLapply(cl, X = c(1:nrow(M2)),fun = OuterFun)
    #tmp <- lapply( X = c(1:nrow(M2)),FUN = OuterFun)
    D2 <- matrix(unlist(tmp),nrow = nrow(M2), ncol = nrow(M2))
    rownames(D2) <- colnames(D2) <-  rownames(M2)
    stopCluster(cl)
  }
 if(method=="cosine"){
     D2 <- as.matrix(cosine(as.matrix(t(M2)))) #distance measure is cosine distance
   
 }

  
  else{
     D2 <- as.matrix(dist(as.matrix(M2),method = paste(method)))
  }
  D2[is.na(D2)] <- 0
  #Col <- colSums(D2)
  #Row <- rowSums(D2)
  rownames(D2) <- colnames(D2) <-  rownames(M2)
  return(D2)
}

@

<<Dist.cyto Function, echo=FALSE>>=
distandcyto<- function(M,method,low.cutoff,high.cutoff, filename=NULL,Min = 4,minparents =8, MinRow = 0, Threads = NULL){
#GoTheDist <- function(M,Min = 4,minparents =   8, MinRow = 0, Threads = NULL){
  require(parallel)
  M2 <- M[,(as.vector(apply(M,2,function(x) sum(x > 0))) > Min)]
  parent <- as.numeric(apply(X=M2,MARGIN=2,max))
  M2 <- M2[,parent >= minparents]
  M2 <- M2[rowSums(M2) > MinRow,]
  
  if(method=="cosine"){
     D2 <- as.matrix(cosine(as.matrix(t(M2)))) #distance measure is cosine distance
   
  }
 
  else{
     D2 <- as.matrix(dist(as.matrix(M2),method = paste(method)))
  

  }
 
  D2[is.na(D2)] <- 0
  #Col <- colSums(D2)
  #Row <- rowSums(D2)
  rownames(D2) <- colnames(D2) <-  rownames(M2)
  #return(D2)

#}

#cyto <- function(D,cutoff = 0.5){
  
  tmp <- melt(t(D2))
  tmp2 <- tmp[tmp$value > low.cutoff & tmp$value < high.cutoff,] 
  if(method=="cosine"){
    tmp2$value <- 1 - tmp2$value ## put in an if else statement, only do this for cosine (for now)
  }
  
  #tmp2$combname <- as.vector(unlist(apply(tmp2, 1, Names)))
  #tmp2$X3 <- do.call("rbind",strsplit(tmp2$combname,".",fixed =TRUE))[,1]
  #tmp2$X4 <- do.call("rbind",strsplit(tmp2$combname,".",fixed =TRUE))[,2]
  #tmp3 <- unique(tmp2[,c(3,5,6)])
  colnames(tmp2) <- c("origin","destination","distance")
  #return(tmp2)
  fortable<- na.exclude(tmp2)
  #return(fortable)
  if(is.null(filename)){
  return(fortable)  
  }
  else if(!is.null(filename)){
  write.table(fortable,row.names = F,file = paste(filename,".txt",sep=""),col.names = T,sep="\t",quote=F)
  return(fortable)  

  }

}
dist.stat<- function(dis){
  if(class(dis)=="data.frame"){
    dis<-dis[,3]
  }
  if(class(dis)=="matrix"){
    dis<-dis
  }
  
  genes_kept<-length(dis)
  mean<-mean(dis)
  median<- median(dis)
  stdev<- sd(dis)
  min<- min(dis)
  max<-max(dis)
  summary<-c(genes_kept,mean,median,stdev,min,max)
  
  names(summary)<- c("genes_kept","mean","median","stdev","min","max")
  summary<-format(summary, scientific=F,digits=4)
  return(summary)
}


cyto <- function(D,low.cutoff,high.cutoff,method){
  
  tmp <- melt(t(D))
  tmp2 <- tmp[tmp$value > low.cutoff & tmp$value < high.cutoff,]
  if(method=="cosine"){
    tmp2$value <- 1 - tmp2$value ## put in an if else statement, only do this for cosine (for now)
  }
  
  #tmp2$combname <- as.vector(unlist(apply(tmp2, 1, Names)))
  #tmp2$X3 <- do.call("rbind",strsplit(tmp2$combname,".",fixed =TRUE))[,1]
  #tmp2$X4 <- do.call("rbind",strsplit(tmp2$combname,".",fixed =TRUE))[,2]
  #tmp3 <- unique(tmp2[,c(3,5,6)])
  colnames(tmp2) <- c("origin","destination","distance")
  #return(tmp2)
  fortable<- na.exclude(tmp2)
  #return(fortable)
 
}
findTerms <- function(M,geneA,geneB=NA,geneC=NA,geneD=NA){
  genecount <- 1
  a <- M[geneA,] 
  a <- names(a[which(a > 0)])
  if(!is.na(geneB)){
    genecount  = genecount + 1
    b <- M[geneB,] 
    a <- c(a,names(b[which(b > 0)]))
  }
  if(!is.na(geneC)){
    genecount  = genecount + 1
    b <- M[geneC,] 
    a <- c(a,names(b[which(b > 0)]))
  }
  if(!is.na(geneD)){
    genecount  = genecount + 1
    b <- M[geneD,] 
    a <- c(a,names(b[which(b > 0)]))
  }
  a <- table(a)
  return(names(a[a==genecount]))
}

@

<<Cutoff Function, echo=FALSE>>=
cutoff<- function(data,method,stringency,Min,minparents){
  
  d.initial<- GoTheDist(data,method=paste(method),Min=Min,minparents=minparents)

  q<-quantile(d.initial,c(.05,.25,.5,.75,.95))
  
  if(method=="cosine"){
    qq<-match(T,q!=0)
  cut<- distandcyto(data, method=paste(method),low.cutoff=q[qq],high.cutoff=Inf,Min=Min,minparents=minparents )
  }
  else{
  cut<- distandcyto(data, method=paste(method),low.cutoff=-Inf,high.cutoff=q[3],Min=Min,minparents=minparents )
  }
  
  dist<- cut[,3]
  peaks<- amps(dist)$Peaks
  sec_peak<- peaks[2,1]
  s_t_midpoint<- mean(c(peaks[3,1],peaks[2,1]))
  third_peak<-peaks[3,1]
  three_four_midpoint<- mean(c(peaks[3,1],peaks[4,1]))
  fourth_peak<-peaks[4,1]
  if(stringency==2){
    return(sec_peak)
  }
  if(stringency==2.5){
    return(s_t_midpoint)
  }
  if(stringency==3){
    return(third_peak)
  }
 
  if(stringency==3.5){
    return(three_four_midpoint)
  }
  if(stringency==4){
    return(fourth_peak)
  }
  
}

#possible improvements:
#include minkowski option? 
#allow users to change number of modes included?

@

<<Symbol Convert, echo=F>>=
#gene.numbers <- read.csv("~/Downloads/GeneLists/adhd1.csv")
#gene.numbers <- as.character(as.character(gene.numbers[2:dim(gene.numbers)[1],]#))
#gene.numbers<- as.data.frame(gene.numbers)
#gene.numbers=as.vector(gene.numbers)

symbolConvert <- function(x, in.type, out.type){

    if(is.vector(x)==TRUE) {
      x=as.data.frame(x)
    }
#manually set objects for when you are debugging, ignore otherwise  
#in.type="entrezgene"
#out.type="hgnc_symbol"
#x=adhdq
  
mart <- useDataset("hsapiens_gene_ensembl", useMart("ensembl"))
conversions <- getBM(filters= in.type, attributes= c(in.type,out.type),values=x,mart= mart)
#conversions<-conversions[match(x,conversions[,1]),]

row1<-as.character(x[,1])
row2<-as.character(conversions[,1])
nas<-is.na(match(row1,row2))
notfound<-x[grep("TRUE",nas),]

  if(length(notfound)>=1) {
    warning(paste("the following entries were not found:",paste(notfound,sep=",",collapse=" , ")))
  }

c<-conversions[match(row1,row2),]
c<-c[is.na(c[,1])==FALSE,]
c<-c[,2]

return(c)

}


@

<<Pre-created getGo Data,echo=F>>=
#setwd("~/Downloads")
#M<-read.csv("getgo_for_markdown.csv",row.names = 1)
@

\section*{Run}
Use \textbf{getGo()} to create a matrix of GO terms based on your gene list.  GoNetwork improves upon previous functional gene enrichment tools by applying weights to the binary GO term matrix based on the number of parents in the GO hierarchy.
<<getGo, echo=T>>=
#load data:
#line here demonstrating how to load the sample data
#M <- getGo(genes,species = "human")
@


Once the GO term matrix is created, use \textbf{GoTheDist()} to calculate the distances between genes. \textbf{GoTheDist()} allows users to restrict the scope of GO terms based on minimum number of genes that fall under a GO term and minimum number of parents. Users may also choose whether the distances are calculated using the cosine function, manhattan distance or euclidean method: \textit{"cosine", "manhattan" or "euclidean"}.  In this case, the cosine function is used.

\vspace{5mm}
<<GoTheDist, echo=T>>=
#D <- GoTheDist(M,method="cosine",Min=6,minparents=15)
#quantile(D)
@

After distances have been calculated, convert the matrix to Cytoscape format using \textbf{cyto()}. Stringency can be adjusted by changing the lower and upper cutoff values. \textit{low.cutoff} is the minimum distance between two genes for the connection to be sent to cytoscape view, whereas \textit{high.cutoff} is the maximum distance.  \textit{Note: this may be confusing to users because low.cutoff is used for cosine and high.cutoff must be used for euclidean and manhattan.}

<<cyto,echo=T>>=
#tab<-cyto(D,method="cosine",low.cutoff=.5,high.cutoff=Inf)
#head(tab)

@



Users can specify the cutoff values manually, or use \textbf{cutoff()} to calculate the cutoff values automatically.  This function locates the modes in the distribution of distance values and calculates the cutoff value that will provide optimal clustering. \textit{Sentence about stringency after figuring out with Sara}
\vspace{2mm}
<<cutoff,echo=T>>=
#cut<-cutoff(M,method = "cosine",stringency=2.5,Min = 6,minparents = 15)
#cut
@


Then write the resulting matrix to a .txt file.
<<write.table,echo=T>>=
#forcyto<-cyto(D,method="cosine",low.cutoff=cut,high.cutoff=Inf)
#write.table(forcyto,row.names = F,file = "forcyto.txt",col.names = T,sep=",")
@

% \begin{figure}[!htb]
% \centering
% \includegraphics[width=6cm,height=6cm,angle=-90]{cosinehist.pdf}
% \caption{Histogram of distance value distribution after cutoff was applied
% \label{fig:filename1}}
% \end{figure}
% 
% \begin{figure}[!htb]
% \centering
% \includegraphics[width=6cm,height=6cm,angle=-90]{test1.png}
% \caption{Cluster Diagram Generated in Cytoscape
% \label{fig:filename1}}
% \end{figure}

\newpage
\subsection*{Other Functions Included}

Use \textbf{symbolConvert()} to convert alternative gene notations to the desired format.  In this case, a list of entrezgene IDs are converted to their respective HGNC gene symbols.

<<symbolconvert, echo=T>>=
#head(gene.numbers)
#gene.symbols<-symbolConvert(gene.numbers,"entrezgene","hgnc_symbol")
#head(gene.symbols)
@



Use \textbf{exactTerms()} to identify GO terms containing a specified character string
<<exactTerms, echo=T>>=
#e<-exactTerms(colnames(M), term = "vesicle")
#head(e)
#Note: ask Sara if this is the correct use of the function
@
\vspace{4mm}
Use \textbf{findGenes()} to return a list of genes with GO terms containing a specified character string.  We can use one of the terms found using the exactTerms() function above:
<<findGenes, echo=T>>=

#head(findGenes(M, term = "acrosomal.vesicle"))

@
\vspace{4mm}

If you would like to identify the GO terms that a group of genes have in common, for instance, a list of genes taken from a cluster seen after plotting in cytoscape, use \textbf{findTerms()}:
<<findTerms, echo=T>>=

#findTerms(M, geneA = "APOE" ,geneB = "FNBP1L",geneC="TBC1D10A")
@




\end{document}